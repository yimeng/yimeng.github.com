<!doctype html><html lang=zh-cn><title>基础设施即代码-PXE | 出租窝</title>
<meta charset=utf-8><meta name=generator content="Hugo 0.125.3"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=canonical href=https://git.yimeng.ch/post/2021/pxe/><link rel=alternate type=application/rss+xml href title=出租窝><link rel=stylesheet href=https://git.yimeng.ch/css/theme.css><link rel=stylesheet href=https://git.yimeng.ch/css/classes.css><header class=dark><h2><a href=https://git.yimeng.ch/>出租窝</a></h2><nav></nav></header><article><header><h1><a href=https://git.yimeng.ch/post/2021/pxe/>基础设施即代码-PXE</a></h1><p class=meta><time datetime=2021-08-30T23:22:00+08:00>August 30, 2021</time></p></header><h1 id=基础设施即代码-pxe>基础设施即代码-PXE</h1><p>自从上次搞定了homelab机器之后，就开始基础设施即代码的第一步了 PXE启动。</p><p>也许你要问了，现在云这么方便PXE这玩意还用得上吗？话说还真是这样，目前大多数时候我们已经用不上这个古老的技术了。在很久以前无盘工作站或者虚拟化的时候，这玩意还是很吃香的。不过这并不影响我们作为一个技术去了解它。而且，现在的一些云厂商或者需要做烧制镜像之前，用PXE还是可以能省不少事的。况且还可以在没有U盘的时候安装系统，何乐不为？（别问我怎么知道的，机器到了之后我就经历了到处借U盘装系统的窘境）</p><p>前面介绍完了，下面开始介绍这个古老的技术吧：</p><h2 id=pxe>PXE</h2><p>先来一段维基百科上的介绍</p><blockquote><p><strong>预启动执行环境</strong>（<strong>Preboot eXecution Environment</strong>，<strong>PXE</strong>，也被称为<strong>预执行环境</strong>）提供了一种使用网络接口（Network Interface）启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备（如硬盘）或本地已安装的操作系统。</p><p>PXE当初是作为<a href=https://zh.wikipedia.org/wiki/Intel>Intel</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%89%E7%BA%BF%E7%AE%A1%E7%90%86&amp;action=edit&amp;redlink=1">有线管理</a>体系的一部分，<a href=https://zh.wikipedia.org/wiki/Intel>Intel</a> 和 <a href="https://zh.wikipedia.org/w/index.php?title=Systemsoft&amp;action=edit&amp;redlink=1">Systemsoft</a>于1999年9月20日公布其规格(版本2.1)[<a href=https://zh.wikipedia.org/wiki/%E9%A2%84%E5%90%AF%E5%8A%A8%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83#cite_note-pxespec-1>1]</a>。通过使用像<a href=https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE>网际协议</a>（IP）、<a href=https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE>用户数据报协议</a>（UDP）、<a href=https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E8%AE%BE%E5%AE%9A%E5%8D%8F%E5%AE%9A>动态主机设定协定</a>（DHCP）、<a href=https://zh.wikipedia.org/wiki/BOOTP>BOOTP</a>、<a href=https://zh.wikipedia.org/wiki/%E5%B0%8F%E5%9E%8B%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE>小型文件传输协议</a>（TFTP）等几种<a href=https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE>网络协议</a>和<a href=https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6>全局唯一标识符</a>（GUID）、<a href=https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E6%8E%A5%E5%8F%A3>通用网络驱动接口</a>（UNDI）、<a href=https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81>通用唯一识别码</a>（UUID）的概念并通过对客户机（通过PXE自检的电脑）<a href=https://zh.wikipedia.org/wiki/%E5%9B%BA%E4%BB%B6>固件</a>扩展预设的<a href=https://zh.wikipedia.org/wiki/API>API</a>来实现目的。</p></blockquote><p>这里可以看出来，这玩意涉及的技术主要有如下两个：</p><ul><li>DHCP（IP）</li><li>TFTP（UDP 69）</li></ul><p>相关的流程借用下往上的图片</p><p><img src=https://yimeng.cn-bj.ufileos.com/blog/20210830233150.png alt=PXE流程></p><ol><li>主机对DHCP服务器说，给我一个IP地址，并且给我一个TFTP地址（<a href=https://datatracker.ietf.org/doc/html/rfc5859>RFC5859</a> Option Codes 128-223）。</li><li>主机用TFTP协议去主机上下载启动所需的引导文件<a href=https://en.wikipedia.org/wiki/SYSLINUX#PXELINUX>pxelinux.0</a>和配置文件pxelinux.cfg/default（<a href=https://datatracker.ietf.org/doc/html/rfc5071>rfc5071</a> Option Codes 209-211）。这个文件的引导顺序<a href="https://wiki.syslinux.org/wiki/index.php?title=PXELINUX">参见这里</a></li><li>从pxelinux.cfg/default文件中把kennel文件vmlinuz，initrd.img下载回来进行引导。</li><li>再向DHCP为linux内核请求一个IP地址。</li><li>使用第二次请求的IP地址，将ks.cfg下载下来进行自动化安装。</li><li>可选：将需要安装的操作系统通过http的方式将ks文件和iso文件放到某目录下，这个就是default文件之后的事情了。<del>这玩意其实就是个<a href=https://zh.wikipedia.org/wiki/GNU_GRUB>GRUB</a></del> 。这里牵涉到了另外几个知识点。一会详细介绍，先把pxelinux.cfg/default的配置放出来。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#75715e>#cat pxelinux.cfg/default</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>default vesamenu.c32</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>prompt 0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>timeout 3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ONTIMEOUT CentOS 7</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>LABEL CentOS 7</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>MENU LABEL CentOS 123</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>KERNEL vmlinuz</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>#APPEND ks initrd=initrd.img ramdisk_size=100000 ksdevice=eth1 ip=dhcp url --url http://192.168.33.11/</span>
</span></span><span style=display:flex><span>  	<span style=color:#a6e22e>append initrd</span><span style=color:#f92672>=</span><span style=color:#e6db74>initrd.img ks=tftp://xxx.xxx.xxx.xxx/anaconda-ks.cfg</span>
</span></span></code></pre></div><p>好了 下面开始说一下关于引导的知识点了</p><h2 id=有关引导>有关引导</h2><p>关于引导维基百科里有一个专业的<a href=https://en.wikipedia.org/wiki/Comparison_of_boot_loaders>对比</a></p><p>不过在这之前先说一下BIOS和UEFI的区别和对比吧</p><p>当然也少不了MBR和GPT的对比</p><p>作为好久不碰硬件的人来说，我的知识水平还停留在BIOS+MBR的时代。</p><h3 id=bios-vs-uefi>BIOS vs UEFI</h3><p>一句话总结就是BIOS是很久以前用于跟硬件打交道的，一般跟磁盘上的MBR配合使用，但后来由于时代发展。BIOS有那么一点点跟不上时代了。就产生了UEFI，就是这么简单。但其实BIOS这个词应该是包含UEFI的，说白了就是跟各种硬件打交道的“操作系统”。只要你一开机执行的就是他们，他们再负责从各种地方，比如说磁盘的MBR或者GPT区域把操作系统引导起来。</p><p>具体详情可以参考知乎：<a href=https://www.zhihu.com/question/21672895>UEFI 引导与 BIOS 引导在原理上有什么区别？</a></p><h3 id=mbr-vs-gpt>MBR vs GPT</h3><p>这两位兄弟其实是针对BIOS/UEFI 之后的磁盘引导来说的，网络启动其实跟他俩没啥太大的关系。</p><p>如果启动设备是磁盘，就要读取MBR/GPT上的信息载入，再从这些信息中识别操作系统。</p><p>MBR：一段磁盘里的玄学区域，DOS时代只能用fdisk /mbr来备份或者覆盖。有这祖传四个主分区的习惯。</p><p>GPT：无限分区，支持大于2.2T磁盘，不区分主分区逻辑分区啥的概念了。反正就是较为先进的一种磁盘引导格式。</p><p>具体详情可以参考知乎<a href=https://www.zhihu.com/question/28471913>UEFI+GPT与BIOS+MBR各自有什么优缺点？</a></p><p>说完一开机的BIOS/UEFI+MBR/GPT之后，就来到我们的主角<a href=https://zh.wikipedia.org/wiki/%E5%95%9F%E5%8B%95%E7%A8%8B%E5%BC%8F>引导程序</a>了。</p><p>另外说一句 PXE的DHCP的过程其实跟这个磁盘上的MBR/GPT过程差不太多，因为刚刚介绍过了，这里就不赘述了。</p><h3 id=引导程序>引导程序</h3><p>常见的如下</p><ul><li><a href=https://en.wikipedia.org/wiki/GNU_GRUB>GNU GRUB</a>：基本上搞Linux的应该没有不知道这个的，还经常被用到了各种装机光盘中。但这个引导程序有个小问题，虽然支持网络启动，但是可能资料比较难找。所以在PXE这个事情上，大家都转投了SYSLINUX</li><li><a href=https://en.wikipedia.org/wiki/SYSLINUX>SYSLINUX</a>：经常用来当成各种Linux的Live光盘上的引导程序，并且包含的PXELinux基本上一统PXE启动的江山了。</li><li><a href=https://en.wikipedia.org/wiki/Windows_Boot_Manager>Windows Boot Manager</a>：根据资料显示会有三个组件出现bootmgr winload.exe winresume.exe具体实在是没有经历去研究了，看起来跟以前DOS时代的CONFIG.SYS、COMMAND.COM、AUTOEXEC.BAT还有IO.SYS、MSDOS.SYS差不多。</li></ul><p>那么我们的PXE所使用的<a href="https://wiki.syslinux.org/wiki/index.php?title=PXELINUX">syslinux</a>里的default配置文件格式看起来跟GRUB里的配置文件很像，但确实不是。相关的语法应该所有区别。syslinux的配置文件<a href="https://wiki.syslinux.org/wiki/index.php?title=Config">详见这里</a>，GRUB的配置文件<a href=https://wiki.archlinux.org/title/GRUB#Custom_grub.cfg>详见这里</a></p><p>引导程序还有很多很多，并且功能也不尽相同，详见可以看下wiki中的矩阵图。</p><h2 id=有关协议>有关协议</h2><p>既然是PXE，技术里逃不出DHCP和TFTP，HTTP虽然也可以算，但毕竟不是主角，且内容较多，这里先略过了。</p><h3 id=dhcp>DHCP</h3><p>这个协议主要就是用于给终端动态分配IP地址，来达到IP地址复用，有效利用IP地址池。并且也加入了一些管理的功能。这些管理的功能就包含了PXE所需的几个重要Option Codes :</p><ul><li><a href=https://tools.ietf.org/html/rfc4578>RFC 4578</a> - November 2006 - DHCP Options for PXE</li><li><a href=https://tools.ietf.org/html/rfc5071>RFC 5071</a> - December 2007 - DHCP Options used by PXELINUX</li></ul><h3 id=tftp>TFTP</h3><p>这个协议其实在没啥好介绍的，比FTP简单很多很多，没有了什么主动被动模式。20 21端口啥的区分。就监听一个UDP69的端口即可。但有时候过于简单，甚至不能列出目录的文件。所以临时用来传个小文件倒没什么问题。这里就不做过多赘述了。</p><h2 id=需要做啥>需要做啥</h2><ul><li>在DHCP上设置好<strong>Next Server</strong>和<strong>Boot File Name</strong>参数</li><li>找台在DHCP可达范围内的服务器，开个TFTP服务。</li><li>TFTP里面放上<ul><li>pxelinux.0 引导文件</li><li>pxelinux.cfg/default 配置文件</li><li>vmlinuz，initrd.img 两个文件</li><li>anaconda-ks.cfg 自动安装脚本</li></ul></li><li>找个机器可以启动了</li></ul><h2 id=注意事项>注意事项</h2><ul><li>别在生产环境中晚DHCP。</li><li>别设置PXE作为第一启动，最好是磁盘找不到了再用PXE启动。（危险系数小一些，但不可避免还是有风险）</li><li>那个选择菜单可用可不用，找不到而已，默认还会正常加载的。</li></ul><h2 id=后记>后记</h2><p>这个PXE中间停顿了3-5天，导致有点虎头蛇尾，后来都不知道自己要写啥了。看起来以后先把大纲打好，一鼓作气再而衰三而竭。下一次应该写写自动化安装完毕的cloud-init，再接下来应该是puppet、ansible、salt了。</p></article></html>